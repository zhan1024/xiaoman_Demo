没了解过，于是只能从头百度开始学习。
Q：什么是锁？|
A:在计算机科学中，锁是一种同步机制，用于控制多个线程对共享资源的访问。锁可以确保在某个线程正在访问资源，从而避免数据竞争和不一致性的问题。

常见的锁包括：
1.互斥锁：最常见的一种锁类型，用于保护共享资源。一次只能有一个线程持有互斥锁，其他线程必须等待锁释放后才能获取锁并访问资源。
2.读写锁：允许多个线程同时读取共享资源，但只允许一个线程写入共享资源。这种锁可以提高读取操作的并发性能。
3.自旋锁：当一个线程尝试获取锁时，如果锁已被其他线程持有，它会反复地尝试获取锁，而不是将自己挂起等待。自旋锁适用于持有时间短暂的情况，避免了线程的开销。
4.条件变量锁：在线程等待某个条件成立时使用。当条件不满足时，线程会进入等待状态，并释放锁，当条件满足时，线程被唤醒并重新获取锁。
5.递归锁：允许同一个线程多次获取同一个锁，避免了死锁的发生，但需要注意解锁的次数要和加锁的次数匹配。
锁的使用可以确保多线程程序的安全性和正确性，避免了竞态条件和数据不一致的问题。然而，不正确地使用锁也可以导致死锁、饥饿等问题，因此需要谨慎使用并遵循良好的锁使用原则。
Q：什么是死锁？
A:死锁是指在多个进程（或线程）之间，彼此持有对方所需资源而无法继续执行的一种状态。简单来说，就是两个或者多个进程等待对方释放资源，导致他们都无法继续执行下去。
死锁通常发生在并发程序中，其中包含多个进程或线程，这些进程或者线程需要获取共享资源才能继续执行。当每个进程都持有一些资源，并且等待其他进程释放它所需的资源时，就可能出现死锁的情况。
死锁发生的四个必要条件是：
1.互斥条件：资源只能被一个进程或线程占用，不能同时被多个进程或者线程占用
2.请求与保持条件：一个进程或者线程在请求新的资源时，同时保持对已有资源的占用
3.不剥夺条件：已经分配给进程或者线程的资源不能被强制性剥夺，只能由持有资源的进程或者线程自愿释放。
4.环境等待条件：存在一个进程或线程等待链，使得每个进程或者线程都在等待下一个进程或线程所持有的资源。
当这四个条件同时满足时，就可能导致死锁的发生。死锁是并发编程中需要特别注意和避免的一种情况，因为它会导致程序无法继续执行，造成资源浪费和系统性能下降。
个人简单总结一下就是：当两个或者多个线程他们彼此都持有一些资源时，这些资源只能一个线程占用，并且这些资源只能靠他们自己资源释放，不能强制释放的时候，外部环境还是存在着其他线程在等待他们的资源时，就可能出现死锁。