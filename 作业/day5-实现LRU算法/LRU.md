### 概念
LRU(least Recently Used 最近最少使用)算法是一种常见的缓存淘汰算法,用于缓存空间不足时选择哪些项目应该被移除,以便为新的数据腾出空间.
### LRU与Vue的keep-alive
LRU 算法的基本原理是根据数据的访问顺序来决定缓存的淘汰顺序。当缓存空间已满时，会将最近最少使用的数据块从缓存中淘汰出去，为新的数据块腾出空间。

Vue 的 <keep-alive> 组件也类似地维护了一个缓存队列，按照组件的访问顺序进行缓存和淘汰。当一个被 <keep-alive> 包裹的组件被激活时，它会被加入缓存队列的末尾；当缓存队列已满时，最近最少被访问的组件会被从缓存中移除，为新的组件腾出空间。
#### 区别
1.缓存策略不完全相同：LRU 算法是一种缓存淘汰策略，它根据数据的访问顺序来决定淘汰哪些数据。而 <keep-alive> 组件是用于缓存 Vue 组件的抽象组件，它会缓存被包裹的组件实例，避免重复的创建和销毁。它并没有直接参考 LRU 算法的淘汰策略，而是通过设置 max 属性来控制缓存的最大数量。

2.缓存顺序处理不同：LRU 算法会根据数据的访问顺序，将最近最少使用的数据淘汰出去。而 <keep-alive> 组件在缓存时，按照组件的激活顺序进行缓存，并通过 max 属性控制缓存的最大数量。当缓存达到最大数量时，旧的缓存组件会被销毁，新的组件则继续缓存。

3.数据结构不同：LRU 算法通常使用链表和哈希表来实现缓存数据的管理，以便在 O(1) 时间内进行插入、删除和查找操作。而 <keep-alive> 组件内部则使用了一个简单的数组来存储缓存的组件实例。当需要销毁或获取缓存时，会根据数组中的位置进行操作。

虽然 <keep-alive> 组件的实现与 LRU 算法有一些相似之处，但它更关注组件的生命周期管理和状态维护，以提供更好的组件缓存机制。